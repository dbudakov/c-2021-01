# Типы данных

`04:00`
_Bool
_Complex
_Imaginary

`06:00` Спецификаторы
10 - int
10L -long
10LL -long long
10ULL - unsigned long long

`10:50` Спецификатор
short `%hd`

## inttypes.h

`15:15` #include <inttypes.h>
`itn8_t` принимает макс 127

`21:00` сложение значений различных типов

__`21:00`__ проработать!
преобразование:
```c
char ch = 'Я';
int i = (int)ch; 
```

`23:30` `inttypes.h`
`int8_t`		- целочисленный тип с точной шириной
`int_least8_t`	- тип с минимальной шириной
`int_fast8_t`	- высокоскоростной тип с минимальной шириной
`intmax_t`		- максимально возможный целочисленный тип

`PRld32` - оптимальный спицификатор

__`28:15`__ интересная запись

```c
printf("si_8 = %" PRId8, si_8);
```

`33:00` шестнадцатиричное представление _float_, через мантису
`34:00` 5.0 - double, 5.0 float, 5.9 - long double
`35:30` вещественные спецификаторы: float/double: %f, %e, %a; long double: %Lf, %Le, %La

## Пользовательские типы данных
Структуры, объединения, перечисления, typedef

```c
// Определение структуры
struct имя_типа_структуры {
	тип имя_переменной_1;
	...
	тип имя_переменной_N;
} имя_экземпляра_структуры;

// Доступ к переменным:
имя_экземпляра_структуры.имя_переменной
```

`44:00` расположение структуры в памяти
Пример:

```c
struct student{
	int number;
	char code[4];
	float cost;
}
struct student otus;
```

```c
// Инициализация
struct student otus = {2021, "Gr_C", 4.5};
```

```c
// Назначенная инициализация
// 4.5 затрет значение cost, так как идет определение после запятой, переменной code   
struct student otus = {.cost = 3.0, .code ="Gr_C", 4.5};
```

```c
// Доступ
otus.number
```

**Массив структур**

```c
// Массив структур
struct student otus[30];

// Вызов
otus[i].number
```

__50:00__ уточнить, динамический массив структур
**Динамический массив структур**

```c
// Динамический массив структур
// Объявляем указатель
struct student *otus; 

// Выделяем память, count_rec - макрос, переменная
otus = (struct student*) malloc(count_rec * sizeof(struct student));


	(otus)->number
	(*otus).number
```

**Передача в функцию**

```c
// Передача частей структуры в функцию
f(otus.number); f(otuc.code); f(otus.code[3]);

// Передача структуры в качестве аргумента, передается вся структура, не адрес и работа идет с копией, сама структура не меняется, для изменении структуры передается указатель
int f_num(struct student o)
	f_num(otus);

// ВАЖНО: структура копируется в стек, размер которого ограничен, чтобы это обойти для больших структур, в функцию передается указатель и в стек попадает только указатель

// Передача структуры через указатель
int f_num(struct student *o)
	f_num(&otus);
```

#### Вложенность структур

```c
struct names{char first_n[25], char last_n[50]};
struct student{struct names fio, int year_b, ...}
```

#### Инициализация и присвоение одной структуры другой

```c
struct names fio1 = {"Иван", "Иванов"}
struct names fio2 = fio1;

// or

fio2 = fio1;
```

## Объединения 01:13:00

**Объединения** - это тип данных, который позволяет хранить переменные разных типов в одном и том же месте памяти( но не одновременно), размер памяти будет соответствовать самому большому элементу объединения

 ```c
union имя_типа{
	тип имя_элемента_1;
	...
	тип имя_элемента_N ;
}
```

```c
// Инициализация
union types{
	int digit;
	double bigNum;
	char latter;
};

union types p_char;
p_char.latter = 'A';
```

```c
// иницилизация другим объединением
union types p_char2 = p_char; 
```

```c
// инициализация первого элемента
union p_int = {50}; 
```

```c
//назначенный инициализатор
union types p_dbl = {.bigNum = 50.0}; 
```

__Уточнить__ enum
#### Перечисляемый тип 
**Перечисляемый тип** - используется для объявления симвользных имен, соответствующих целочисленным константам

```c
enum имя_типа {имя 1 = значение 1, имя2 = значение2, ...} переменная
```

`01:20:00` enum это целочисленный тип и если выводить его значение через %d, то будет выводиться 1,2,3,4 соответственно элементу

```c
enum spectr{red,orange,yellow,green. blue};
enum spectr color;
```

```c
// присваивание индексов
enum levels {low = 1, medium = 5, high = 10};
```

```c
// dog присваивается индекс 10, puma будет уже 11
enum enimals{cat,dog = 10, puma,tiger};
```

#### typedef(алиас)

Оператор _typedef_ позволяет связать новые типы данных с существующими

```c
typedef существующий_тип новый_тип;
```

- выполняется компилятором,
- область видимости зависит от местоположения
- используется при создании удобных имен для часто используемых типов

`01:26:23`

```c
// разница typedef и define, во втором случае p2 будет просто переменной, а в первом это указатель
typedef char * STRING;
STRING p1,p2; <==> char *p1, *p2;

#define STRING char*
STRING p1,p2; <==> char *p1,p2;
```

```c
// задание алиаса структуры
typedef struct{float real; float imag;} COMPLEX;
```

## Дополнительно

библиотека `gmp.h` для работы с числами

### Фишки

`1:10:00`

```c
// Разница в выделении памяти, во втором случае сложно предсказать где выделится память, в то время как в первом память выделяется внутри структуры
struct names{char first_n[25],char last_n[50]};
struct names{char *first_n, char *last_n};
```
